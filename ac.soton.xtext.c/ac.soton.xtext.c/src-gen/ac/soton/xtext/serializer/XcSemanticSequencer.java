/*
 * generated by Xtext 2.25.0
 */
package ac.soton.xtext.serializer;

import ac.soton.xtext.services.XcGrammarAccess;
import com.google.inject.Inject;
import ecore.CArrayVariable;
import ecore.CEnumProperties;
import ecore.CEnumeration;
import ecore.CExpression;
import ecore.CField;
import ecore.CFunction;
import ecore.CIncludeDirective;
import ecore.CParameter;
import ecore.CPointer;
import ecore.CPreCondition;
import ecore.CProcedure;
import ecore.CSourceFile;
import ecore.CStruct;
import ecore.CType;
import ecore.CVariable;
import ecore.EcorePackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XcSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XcGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EcorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EcorePackage.CARRAY_VARIABLE:
				sequence_CArrayVariable(context, (CArrayVariable) semanticObject); 
				return; 
			case EcorePackage.CENUM_PROPERTIES:
				sequence_CEnumProperties(context, (CEnumProperties) semanticObject); 
				return; 
			case EcorePackage.CENUMERATION:
				sequence_CEnumeration(context, (CEnumeration) semanticObject); 
				return; 
			case EcorePackage.CEXPRESSION:
				sequence_CExpression(context, (CExpression) semanticObject); 
				return; 
			case EcorePackage.CFIELD:
				sequence_CField(context, (CField) semanticObject); 
				return; 
			case EcorePackage.CFUNCTION:
				sequence_CFunction(context, (CFunction) semanticObject); 
				return; 
			case EcorePackage.CINCLUDE_DIRECTIVE:
				sequence_CIncludeDirective(context, (CIncludeDirective) semanticObject); 
				return; 
			case EcorePackage.CPARAMETER:
				sequence_CParameter(context, (CParameter) semanticObject); 
				return; 
			case EcorePackage.CPOINTER:
				sequence_CPointer(context, (CPointer) semanticObject); 
				return; 
			case EcorePackage.CPRE_CONDITION:
				sequence_CPreCondition(context, (CPreCondition) semanticObject); 
				return; 
			case EcorePackage.CPROCEDURE:
				if (rule == grammarAccess.getCSubProgramRule()
						|| rule == grammarAccess.getCProcedureRule()) {
					sequence_CProcedure(context, (CProcedure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getContextRule()) {
					sequence_Context(context, (CProcedure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInitialisationRule()) {
					sequence_Initialisation(context, (CProcedure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMainRule()) {
					sequence_Main(context, (CProcedure) semanticObject); 
					return; 
				}
				else break;
			case EcorePackage.CSOURCE_FILE:
				sequence_CSourceFile(context, (CSourceFile) semanticObject); 
				return; 
			case EcorePackage.CSTRUCT:
				sequence_CStruct(context, (CStruct) semanticObject); 
				return; 
			case EcorePackage.CTYPE:
				sequence_CType(context, (CType) semanticObject); 
				return; 
			case EcorePackage.CVARIABLE:
				sequence_CVariable_Impl(context, (CVariable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CVariable returns CArrayVariable
	 *     CArrayVariable returns CArrayVariable
	 *
	 * Constraint:
	 *     ((type=EString name=EString) | (type=EString? name=EString value=EString) | (type=EString name=EString size=EInt) | (type=EString name=EString))
	 */
	protected void sequence_CArrayVariable(ISerializationContext context, CArrayVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CEnumProperties returns CEnumProperties
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CEnumProperties(ISerializationContext context, CEnumProperties semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCEnumPropertiesAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CType returns CEnumeration
	 *     CEnumeration returns CEnumeration
	 *
	 * Constraint:
	 *     (name=EString (enumProperties+=CEnumProperties enumProperties+=CEnumProperties*)?)
	 */
	protected void sequence_CEnumeration(ISerializationContext context, CEnumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CExpression returns CExpression
	 *
	 * Constraint:
	 *     (expression=CExpressionHelper | expression=ForLoop)
	 */
	protected void sequence_CExpression(ISerializationContext context, CExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CField returns CField
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CField(ISerializationContext context, CField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCFieldAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CSubProgram returns CFunction
	 *     CFunction returns CFunction
	 *
	 * Constraint:
	 *     (
	 *         returnType=EString 
	 *         name=EString 
	 *         (parameters+=CParameter parameters+=CParameter*)? 
	 *         preconditions+=CPreCondition 
	 *         (localVariables+=CVariable | body+=CExpression)* 
	 *         returnStatement=CExpression 
	 *         endname=EString
	 *     )
	 */
	protected void sequence_CFunction(ISerializationContext context, CFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CIncludeDirective returns CIncludeDirective
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CIncludeDirective(ISerializationContext context, CIncludeDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCIncludeDirectiveAccess().getNameEStringParserRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CParameter returns CParameter
	 *
	 * Constraint:
	 *     (type=EString name=EString)
	 */
	protected void sequence_CParameter(ISerializationContext context, CParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CPARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CPARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCParameterAccess().getTypeEStringParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCParameterAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CPointer returns CPointer
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CPointer(ISerializationContext context, CPointer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CNAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCPointerAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CPreCondition returns CPreCondition
	 *
	 * Constraint:
	 *     expression=CExpressionHelper
	 */
	protected void sequence_CPreCondition(ISerializationContext context, CPreCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcorePackage.Literals.CEXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcorePackage.Literals.CEXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCPreConditionAccess().getExpressionCExpressionHelperParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CSubProgram returns CProcedure
	 *     CProcedure returns CProcedure
	 *
	 * Constraint:
	 *     (name=EString (parameters+=CParameter parameters+=CParameter*)? preconditions+=CPreCondition (localVariables+=CVariable | body+=CExpression)*)
	 */
	protected void sequence_CProcedure(ISerializationContext context, CProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CSourceFile returns CSourceFile
	 *
	 * Constraint:
	 *     (subPrograms+=Context subPrograms+=Initialisation subPrograms+=Main)
	 */
	protected void sequence_CSourceFile(ISerializationContext context, CSourceFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CType returns CStruct
	 *     CStruct returns CStruct
	 *
	 * Constraint:
	 *     (name=EString fields+=CField* type=EString)
	 */
	protected void sequence_CStruct(ISerializationContext context, CStruct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CType returns CType
	 *
	 * Constraint:
	 *     {CType}
	 */
	protected void sequence_CType(ISerializationContext context, CType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CVariable returns CVariable
	 *     CVariable_Impl returns CVariable
	 *
	 * Constraint:
	 *     (isConstant?='const'? type=EString name=EString value=EString?)
	 */
	protected void sequence_CVariable_Impl(ISerializationContext context, CVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns CProcedure
	 *
	 * Constraint:
	 *     (name='context' (localVariables+=CVariable | body+=CExpression)*)
	 */
	protected void sequence_Context(ISerializationContext context, CProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initialisation returns CProcedure
	 *
	 * Constraint:
	 *     (name='initialisation' (localVariables+=CVariable | body+=CExpression)*)
	 */
	protected void sequence_Initialisation(ISerializationContext context, CProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Main returns CProcedure
	 *
	 * Constraint:
	 *     (name='main' (localVariables+=CVariable | body+=CExpression)*)
	 */
	protected void sequence_Main(ISerializationContext context, CProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

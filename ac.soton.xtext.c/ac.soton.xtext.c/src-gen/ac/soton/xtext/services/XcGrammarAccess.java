/*
 * generated by Xtext 2.25.0
 */
package ac.soton.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class XcGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class CSourceFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CSourceFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCSourceFileAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSubProgramsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubProgramsContextParserRuleCall_1_0 = (RuleCall)cSubProgramsAssignment_1.eContents().get(0);
		private final Assignment cSubProgramsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubProgramsInitialisationParserRuleCall_2_0 = (RuleCall)cSubProgramsAssignment_2.eContents().get(0);
		private final Assignment cSubProgramsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSubProgramsMainParserRuleCall_3_0 = (RuleCall)cSubProgramsAssignment_3.eContents().get(0);
		
		//CSourceFile returns xc::CSourceFile:
		//    {xc::CSourceFile}
		////    (includeDirectives += CIncludeDirective |
		////    types += CType |
		////    globalVariables += CVariable |
		////    subPrograms += CSubProgram
		////)*
		//    subPrograms += Context
		//    subPrograms += Initialisation
		//    subPrograms += Main
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//    {xc::CSourceFile}
		////    (includeDirectives += CIncludeDirective |
		////    types += CType |
		////    globalVariables += CVariable |
		////    subPrograms += CSubProgram
		////)*
		//    subPrograms += Context
		//    subPrograms += Initialisation
		//    subPrograms += Main
		public Group getGroup() { return cGroup; }
		
		//{xc::CSourceFile}
		public Action getCSourceFileAction_0() { return cCSourceFileAction_0; }
		
		////    (includeDirectives += CIncludeDirective |
		////    types += CType |
		////    globalVariables += CVariable |
		////    subPrograms += CSubProgram
		////)*
		//    subPrograms += Context
		public Assignment getSubProgramsAssignment_1() { return cSubProgramsAssignment_1; }
		
		//Context
		public RuleCall getSubProgramsContextParserRuleCall_1_0() { return cSubProgramsContextParserRuleCall_1_0; }
		
		//subPrograms += Initialisation
		public Assignment getSubProgramsAssignment_2() { return cSubProgramsAssignment_2; }
		
		//Initialisation
		public RuleCall getSubProgramsInitialisationParserRuleCall_2_0() { return cSubProgramsInitialisationParserRuleCall_2_0; }
		
		//subPrograms += Main
		public Assignment getSubProgramsAssignment_3() { return cSubProgramsAssignment_3; }
		
		//Main
		public RuleCall getSubProgramsMainParserRuleCall_3_0() { return cSubProgramsMainParserRuleCall_3_0; }
	}
	public class CIncludeDirectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CIncludeDirective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCIncludeDirectiveAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIncludeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameEStringParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//CIncludeDirective returns xc::CIncludeDirective:
		//    {xc::CIncludeDirective}
		//    '#include' '<' name=EString '>';
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CIncludeDirective}
		//'#include' '<' name=EString '>'
		public Group getGroup() { return cGroup; }
		
		//{xc::CIncludeDirective}
		public Action getCIncludeDirectiveAction_0() { return cCIncludeDirectiveAction_0; }
		
		//'#include'
		public Keyword getIncludeKeyword_1() { return cIncludeKeyword_1; }
		
		//'<'
		public Keyword getLessThanSignKeyword_2() { return cLessThanSignKeyword_2; }
		
		//name=EString
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_3_0() { return cNameEStringParserRuleCall_3_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}
	public class ContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.Context");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameContextKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cLocalVariablesAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cLocalVariablesCVariableParserRuleCall_3_0_0 = (RuleCall)cLocalVariablesAssignment_3_0.eContents().get(0);
		private final Assignment cBodyAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cBodyCExpressionParserRuleCall_3_1_0 = (RuleCall)cBodyAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Context returns xc::CProcedure:
		//    name="context"
		//    (
		//        '(' ')'
		//    )?
		//    '{'
		//        (
		//            localVariables += CVariable |
		//            body += CExpression
		//        )*
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name="context"
		//(
		//    '(' ')'
		//)?
		//'{'
		//    (
		//        localVariables += CVariable |
		//        body += CExpression
		//    )*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//name="context"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//"context"
		public Keyword getNameContextKeyword_0_0() { return cNameContextKeyword_0_0; }
		
		//(
		//    '(' ')'
		//)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_1() { return cRightParenthesisKeyword_1_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//(
		//    localVariables += CVariable |
		//    body += CExpression
		//)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//localVariables += CVariable
		public Assignment getLocalVariablesAssignment_3_0() { return cLocalVariablesAssignment_3_0; }
		
		//CVariable
		public RuleCall getLocalVariablesCVariableParserRuleCall_3_0_0() { return cLocalVariablesCVariableParserRuleCall_3_0_0; }
		
		//body += CExpression
		public Assignment getBodyAssignment_3_1() { return cBodyAssignment_3_1; }
		
		//CExpression
		public RuleCall getBodyCExpressionParserRuleCall_3_1_0() { return cBodyCExpressionParserRuleCall_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class InitialisationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.Initialisation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameInitialisationKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cLocalVariablesAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cLocalVariablesCVariableParserRuleCall_3_0_0 = (RuleCall)cLocalVariablesAssignment_3_0.eContents().get(0);
		private final Assignment cBodyAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cBodyCExpressionParserRuleCall_3_1_0 = (RuleCall)cBodyAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Initialisation returns xc::CProcedure:
		//    name="initialisation"
		//    (
		//        '(' ')'
		//    )?
		//    '{'
		//        (
		//            localVariables += CVariable |
		//            body += CExpression
		//        )*
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name="initialisation"
		//(
		//    '(' ')'
		//)?
		//'{'
		//    (
		//        localVariables += CVariable |
		//        body += CExpression
		//    )*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//name="initialisation"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//"initialisation"
		public Keyword getNameInitialisationKeyword_0_0() { return cNameInitialisationKeyword_0_0; }
		
		//(
		//    '(' ')'
		//)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_1() { return cRightParenthesisKeyword_1_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//(
		//    localVariables += CVariable |
		//    body += CExpression
		//)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//localVariables += CVariable
		public Assignment getLocalVariablesAssignment_3_0() { return cLocalVariablesAssignment_3_0; }
		
		//CVariable
		public RuleCall getLocalVariablesCVariableParserRuleCall_3_0_0() { return cLocalVariablesCVariableParserRuleCall_3_0_0; }
		
		//body += CExpression
		public Assignment getBodyAssignment_3_1() { return cBodyAssignment_3_1; }
		
		//CExpression
		public RuleCall getBodyCExpressionParserRuleCall_3_1_0() { return cBodyCExpressionParserRuleCall_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class MainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.Main");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameMainKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cLocalVariablesAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cLocalVariablesCVariableParserRuleCall_3_0_0 = (RuleCall)cLocalVariablesAssignment_3_0.eContents().get(0);
		private final Assignment cBodyAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cBodyCExpressionParserRuleCall_3_1_0 = (RuleCall)cBodyAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Main returns xc::CProcedure:
		//    name="main"
		//    (
		//        '(' ')'
		//    )?
		//    '{'
		//        (
		//            localVariables += CVariable |
		//            body += CExpression
		//        )*
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name="main"
		//(
		//    '(' ')'
		//)?
		//'{'
		//    (
		//        localVariables += CVariable |
		//        body += CExpression
		//    )*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//name="main"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//"main"
		public Keyword getNameMainKeyword_0_0() { return cNameMainKeyword_0_0; }
		
		//(
		//    '(' ')'
		//)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_1() { return cRightParenthesisKeyword_1_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//(
		//    localVariables += CVariable |
		//    body += CExpression
		//)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//localVariables += CVariable
		public Assignment getLocalVariablesAssignment_3_0() { return cLocalVariablesAssignment_3_0; }
		
		//CVariable
		public RuleCall getLocalVariablesCVariableParserRuleCall_3_0_0() { return cLocalVariablesCVariableParserRuleCall_3_0_0; }
		
		//body += CExpression
		public Assignment getBodyAssignment_3_1() { return cBodyAssignment_3_1; }
		
		//CExpression
		public RuleCall getBodyCExpressionParserRuleCall_3_1_0() { return cBodyCExpressionParserRuleCall_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class CSubProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CSubProgram");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCProcedureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CSubProgram returns xc::CSubProgram:
		//    CFunction | CProcedure;
		@Override public ParserRule getRule() { return rule; }
		
		//CFunction | CProcedure
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CFunction
		public RuleCall getCFunctionParserRuleCall_0() { return cCFunctionParserRuleCall_0; }
		
		//CProcedure
		public RuleCall getCProcedureParserRuleCall_1() { return cCProcedureParserRuleCall_1; }
	}
	public class CFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCFunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cReturnTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnTypeEStringParserRuleCall_1_0 = (RuleCall)cReturnTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParametersAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParametersCParameterParserRuleCall_3_1_0 = (RuleCall)cParametersAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cParametersAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cParametersCParameterParserRuleCall_3_2_1_0 = (RuleCall)cParametersAssignment_3_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cPreconditionsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPreconditionsCPreConditionParserRuleCall_5_0 = (RuleCall)cPreconditionsAssignment_5.eContents().get(0);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Assignment cLocalVariablesAssignment_6_0 = (Assignment)cAlternatives_6.eContents().get(0);
		private final RuleCall cLocalVariablesCVariableParserRuleCall_6_0_0 = (RuleCall)cLocalVariablesAssignment_6_0.eContents().get(0);
		private final Assignment cBodyAssignment_6_1 = (Assignment)cAlternatives_6.eContents().get(1);
		private final RuleCall cBodyCExpressionParserRuleCall_6_1_0 = (RuleCall)cBodyAssignment_6_1.eContents().get(0);
		private final Keyword cReturnKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cReturnStatementAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cReturnStatementCExpressionParserRuleCall_8_0 = (RuleCall)cReturnStatementAssignment_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Assignment cEndnameAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cEndnameEStringParserRuleCall_10_0 = (RuleCall)cEndnameAssignment_10.eContents().get(0);
		
		//CFunction returns xc::CFunction:
		//    {xc::CFunction}
		//    returnType=EString
		//    name=EString
		//    (
		//        '('
		//        parameters += CParameter ( "," parameters += CParameter)*
		//        ')'
		//    )?
		//    '{'
		//        preconditions += CPreCondition
		//        (
		//            localVariables += CVariable |
		//            body += CExpression
		//        )*
		//        'return' returnStatement=CExpression
		//    '}' endname=EString;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CFunction}
		//returnType=EString
		//name=EString
		//(
		//    '('
		//    parameters += CParameter ( "," parameters += CParameter)*
		//    ')'
		//)?
		//'{'
		//    preconditions += CPreCondition
		//    (
		//        localVariables += CVariable |
		//        body += CExpression
		//    )*
		//    'return' returnStatement=CExpression
		//'}' endname=EString
		public Group getGroup() { return cGroup; }
		
		//{xc::CFunction}
		public Action getCFunctionAction_0() { return cCFunctionAction_0; }
		
		//returnType=EString
		public Assignment getReturnTypeAssignment_1() { return cReturnTypeAssignment_1; }
		
		//EString
		public RuleCall getReturnTypeEStringParserRuleCall_1_0() { return cReturnTypeEStringParserRuleCall_1_0; }
		
		//name=EString
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_0() { return cNameEStringParserRuleCall_2_0; }
		
		//(
		//    '('
		//    parameters += CParameter ( "," parameters += CParameter)*
		//    ')'
		//)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }
		
		//parameters += CParameter
		public Assignment getParametersAssignment_3_1() { return cParametersAssignment_3_1; }
		
		//CParameter
		public RuleCall getParametersCParameterParserRuleCall_3_1_0() { return cParametersCParameterParserRuleCall_3_1_0; }
		
		//( "," parameters += CParameter)*
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }
		
		//parameters += CParameter
		public Assignment getParametersAssignment_3_2_1() { return cParametersAssignment_3_2_1; }
		
		//CParameter
		public RuleCall getParametersCParameterParserRuleCall_3_2_1_0() { return cParametersCParameterParserRuleCall_3_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_3() { return cRightParenthesisKeyword_3_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//preconditions += CPreCondition
		public Assignment getPreconditionsAssignment_5() { return cPreconditionsAssignment_5; }
		
		//CPreCondition
		public RuleCall getPreconditionsCPreConditionParserRuleCall_5_0() { return cPreconditionsCPreConditionParserRuleCall_5_0; }
		
		//(
		//    localVariables += CVariable |
		//    body += CExpression
		//)*
		public Alternatives getAlternatives_6() { return cAlternatives_6; }
		
		//localVariables += CVariable
		public Assignment getLocalVariablesAssignment_6_0() { return cLocalVariablesAssignment_6_0; }
		
		//CVariable
		public RuleCall getLocalVariablesCVariableParserRuleCall_6_0_0() { return cLocalVariablesCVariableParserRuleCall_6_0_0; }
		
		//body += CExpression
		public Assignment getBodyAssignment_6_1() { return cBodyAssignment_6_1; }
		
		//CExpression
		public RuleCall getBodyCExpressionParserRuleCall_6_1_0() { return cBodyCExpressionParserRuleCall_6_1_0; }
		
		//'return'
		public Keyword getReturnKeyword_7() { return cReturnKeyword_7; }
		
		//returnStatement=CExpression
		public Assignment getReturnStatementAssignment_8() { return cReturnStatementAssignment_8; }
		
		//CExpression
		public RuleCall getReturnStatementCExpressionParserRuleCall_8_0() { return cReturnStatementCExpressionParserRuleCall_8_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
		
		//endname=EString
		public Assignment getEndnameAssignment_10() { return cEndnameAssignment_10; }
		
		//EString
		public RuleCall getEndnameEStringParserRuleCall_10_0() { return cEndnameEStringParserRuleCall_10_0; }
	}
	public class CProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CProcedure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCProcedureAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersCParameterParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cParametersCParameterParserRuleCall_2_2_1_0 = (RuleCall)cParametersAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPreconditionsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPreconditionsCPreConditionParserRuleCall_4_0 = (RuleCall)cPreconditionsAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cLocalVariablesAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cLocalVariablesCVariableParserRuleCall_5_0_0 = (RuleCall)cLocalVariablesAssignment_5_0.eContents().get(0);
		private final Assignment cBodyAssignment_5_1 = (Assignment)cAlternatives_5.eContents().get(1);
		private final RuleCall cBodyCExpressionParserRuleCall_5_1_0 = (RuleCall)cBodyAssignment_5_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//CProcedure returns xc::CProcedure:
		//    {xc::CProcedure}
		//    name=EString
		//    (
		//        '('
		//        parameters += CParameter ( "," parameters += CParameter)*
		//        ')'
		//    )?
		//    '{'
		//        preconditions += CPreCondition
		//        (
		//            localVariables += CVariable |
		//            body += CExpression
		//        )*
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CProcedure}
		//name=EString
		//(
		//    '('
		//    parameters += CParameter ( "," parameters += CParameter)*
		//    ')'
		//)?
		//'{'
		//    preconditions += CPreCondition
		//    (
		//        localVariables += CVariable |
		//        body += CExpression
		//    )*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//{xc::CProcedure}
		public Action getCProcedureAction_0() { return cCProcedureAction_0; }
		
		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
		
		//(
		//    '('
		//    parameters += CParameter ( "," parameters += CParameter)*
		//    ')'
		//)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//parameters += CParameter
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }
		
		//CParameter
		public RuleCall getParametersCParameterParserRuleCall_2_1_0() { return cParametersCParameterParserRuleCall_2_1_0; }
		
		//( "," parameters += CParameter)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//parameters += CParameter
		public Assignment getParametersAssignment_2_2_1() { return cParametersAssignment_2_2_1; }
		
		//CParameter
		public RuleCall getParametersCParameterParserRuleCall_2_2_1_0() { return cParametersCParameterParserRuleCall_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//preconditions += CPreCondition
		public Assignment getPreconditionsAssignment_4() { return cPreconditionsAssignment_4; }
		
		//CPreCondition
		public RuleCall getPreconditionsCPreConditionParserRuleCall_4_0() { return cPreconditionsCPreConditionParserRuleCall_4_0; }
		
		//(
		//    localVariables += CVariable |
		//    body += CExpression
		//)*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//localVariables += CVariable
		public Assignment getLocalVariablesAssignment_5_0() { return cLocalVariablesAssignment_5_0; }
		
		//CVariable
		public RuleCall getLocalVariablesCVariableParserRuleCall_5_0_0() { return cLocalVariablesCVariableParserRuleCall_5_0_0; }
		
		//body += CExpression
		public Assignment getBodyAssignment_5_1() { return cBodyAssignment_5_1; }
		
		//CExpression
		public RuleCall getBodyCExpressionParserRuleCall_5_1_0() { return cBodyCExpressionParserRuleCall_5_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class CPreConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CPreCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cPredicateParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpressionCExpressionHelperParserRuleCall_5_0 = (RuleCall)cExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//CPreCondition returns xc::CPreCondition:
		//    // Used to declare a guard containing basic mathematical comparisons
		//    'if' '(' Predicate ')' '{'
		//        expression=CExpressionHelper
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// Used to declare a guard containing basic mathematical comparisons
		//'if' '(' Predicate ')' '{'
		//    expression=CExpressionHelper
		//'}'
		public Group getGroup() { return cGroup; }
		
		//// Used to declare a guard containing basic mathematical comparisons
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_2() { return cPredicateParserRuleCall_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//expression=CExpressionHelper
		public Assignment getExpressionAssignment_5() { return cExpressionAssignment_5; }
		
		//CExpressionHelper
		public RuleCall getExpressionCExpressionHelperParserRuleCall_5_0() { return cExpressionCExpressionHelperParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class CParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeEStringParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//CParameter returns xc::CParameter:
		//    {xc::CParameter}
		//    type=EString
		//    name=EString;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CParameter}
		//type=EString
		//name=EString
		public Group getGroup() { return cGroup; }
		
		//{xc::CParameter}
		public Action getCParameterAction_0() { return cCParameterAction_0; }
		
		//type=EString
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_1_0() { return cTypeEStringParserRuleCall_1_0; }
		
		//name=EString
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_0() { return cNameEStringParserRuleCall_2_0; }
	}
	public class CVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCVariable_ImplParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCArrayVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CVariable returns xc::CVariable:
		//    CVariable_Impl | CArrayVariable;
		@Override public ParserRule getRule() { return rule; }
		
		//CVariable_Impl | CArrayVariable
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CVariable_Impl
		public RuleCall getCVariable_ImplParserRuleCall_0() { return cCVariable_ImplParserRuleCall_0; }
		
		//CArrayVariable
		public RuleCall getCArrayVariableParserRuleCall_1() { return cCArrayVariableParserRuleCall_1; }
	}
	public class CVariable_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CVariable_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cIsConstantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cIsConstantConstKeyword_1_0 = (Keyword)cIsConstantAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeEStringParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameEStringParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cEqualsSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cValueEStringParserRuleCall_4_1_0 = (RuleCall)cValueAssignment_4_1.eContents().get(0);
		
		//CVariable_Impl returns xc::CVariable:
		//    {xc::CVariable}
		//    (isConstant?='const')?
		//    type=EString // This includes some types e.g. structs and enums which cannot be used but correctly covers pointers
		//    name=EString
		//    ('=' value=EString)? // set to some value or variable
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CVariable}
		//(isConstant?='const')?
		//type=EString // This includes some types e.g. structs and enums which cannot be used but correctly covers pointers
		//name=EString
		//('=' value=EString)?
		public Group getGroup() { return cGroup; }
		
		//{xc::CVariable}
		public Action getCVariableAction_0() { return cCVariableAction_0; }
		
		//(isConstant?='const')?
		public Assignment getIsConstantAssignment_1() { return cIsConstantAssignment_1; }
		
		//'const'
		public Keyword getIsConstantConstKeyword_1_0() { return cIsConstantConstKeyword_1_0; }
		
		//type=EString
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_2_0() { return cTypeEStringParserRuleCall_2_0; }
		
		//// This includes some types e.g. structs and enums which cannot be used but correctly covers pointers
		//   name=EString
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_3_0() { return cNameEStringParserRuleCall_3_0; }
		
		//('=' value=EString)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'='
		public Keyword getEqualsSignKeyword_4_0() { return cEqualsSignKeyword_4_0; }
		
		//value=EString
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }
		
		//EString
		public RuleCall getValueEStringParserRuleCall_4_1_0() { return cValueEStringParserRuleCall_4_1_0; }
	}
	public class CArrayVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CArrayVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCArrayVariableAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeEStringParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cNameAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cNameEStringParserRuleCall_0_3_0 = (RuleCall)cNameAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypeEStringParserRuleCall_1_0_0 = (RuleCall)cTypeAssignment_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cEIntParserRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cEqualsSignKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cValueAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cValueEStringParserRuleCall_1_6_0 = (RuleCall)cValueAssignment_1_6.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cTypeAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cTypeEStringParserRuleCall_2_0_0 = (RuleCall)cTypeAssignment_2_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cNameAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_2_0 = (RuleCall)cNameAssignment_2_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Keyword cMallocKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		private final Assignment cSizeAssignment_2_6 = (Assignment)cGroup_2.eContents().get(6);
		private final RuleCall cSizeEIntParserRuleCall_2_6_0 = (RuleCall)cSizeAssignment_2_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_7 = (Keyword)cGroup_2.eContents().get(7);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cTypeAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cTypeEStringParserRuleCall_3_0_0 = (RuleCall)cTypeAssignment_3_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cNameAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_3_2_0 = (RuleCall)cNameAssignment_3_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Keyword cCallocKeyword_3_4 = (Keyword)cGroup_3.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_3_5 = (Keyword)cGroup_3.eContents().get(5);
		private final RuleCall cMathematicalFormulaParserRuleCall_3_6 = (RuleCall)cGroup_3.eContents().get(6);
		private final Keyword cCommaKeyword_3_7 = (Keyword)cGroup_3.eContents().get(7);
		private final RuleCall cMathematicalFormulaParserRuleCall_3_8 = (RuleCall)cGroup_3.eContents().get(8);
		private final Keyword cRightParenthesisKeyword_3_9 = (Keyword)cGroup_3.eContents().get(9);
		
		//CArrayVariable returns xc::CArrayVariable:
		//    {xc::CArrayVariable}
		//    type=EString'*'
		//    name=EString |
		//    (type=EString)? name=EString '[' EInt ']' '=' value=EString |
		//    type=EString '*' name=EString '=' 'malloc' '(' size=EInt ')'|
		//    type=EString '*' name=EString '=' 'calloc' '(' MathematicalFormula ',' MathematicalFormula ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CArrayVariable}
		//type=EString'*'
		//name=EString |
		//(type=EString)? name=EString '[' EInt ']' '=' value=EString |
		//type=EString '*' name=EString '=' 'malloc' '(' size=EInt ')'|
		//type=EString '*' name=EString '=' 'calloc' '(' MathematicalFormula ',' MathematicalFormula ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{xc::CArrayVariable}
		//type=EString'*'
		//name=EString
		public Group getGroup_0() { return cGroup_0; }
		
		//{xc::CArrayVariable}
		public Action getCArrayVariableAction_0_0() { return cCArrayVariableAction_0_0; }
		
		//type=EString
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_0_1_0() { return cTypeEStringParserRuleCall_0_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_0_2() { return cAsteriskKeyword_0_2; }
		
		//name=EString
		public Assignment getNameAssignment_0_3() { return cNameAssignment_0_3; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_0_3_0() { return cNameEStringParserRuleCall_0_3_0; }
		
		//(type=EString)? name=EString '[' EInt ']' '=' value=EString
		public Group getGroup_1() { return cGroup_1; }
		
		//(type=EString)?
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_1_0_0() { return cTypeEStringParserRuleCall_1_0_0; }
		
		//name=EString
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_1_1_0() { return cNameEStringParserRuleCall_1_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_2() { return cLeftSquareBracketKeyword_1_2; }
		
		//EInt
		public RuleCall getEIntParserRuleCall_1_3() { return cEIntParserRuleCall_1_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_5() { return cEqualsSignKeyword_1_5; }
		
		//value=EString
		public Assignment getValueAssignment_1_6() { return cValueAssignment_1_6; }
		
		//EString
		public RuleCall getValueEStringParserRuleCall_1_6_0() { return cValueEStringParserRuleCall_1_6_0; }
		
		//type=EString '*' name=EString '=' 'malloc' '(' size=EInt ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//type=EString
		public Assignment getTypeAssignment_2_0() { return cTypeAssignment_2_0; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_2_0_0() { return cTypeEStringParserRuleCall_2_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_2_1() { return cAsteriskKeyword_2_1; }
		
		//name=EString
		public Assignment getNameAssignment_2_2() { return cNameAssignment_2_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_2_0() { return cNameEStringParserRuleCall_2_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_3() { return cEqualsSignKeyword_2_3; }
		
		//'malloc'
		public Keyword getMallocKeyword_2_4() { return cMallocKeyword_2_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_5() { return cLeftParenthesisKeyword_2_5; }
		
		//size=EInt
		public Assignment getSizeAssignment_2_6() { return cSizeAssignment_2_6; }
		
		//EInt
		public RuleCall getSizeEIntParserRuleCall_2_6_0() { return cSizeEIntParserRuleCall_2_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_7() { return cRightParenthesisKeyword_2_7; }
		
		//type=EString '*' name=EString '=' 'calloc' '(' MathematicalFormula ',' MathematicalFormula ')'
		public Group getGroup_3() { return cGroup_3; }
		
		//type=EString
		public Assignment getTypeAssignment_3_0() { return cTypeAssignment_3_0; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_3_0_0() { return cTypeEStringParserRuleCall_3_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_3_1() { return cAsteriskKeyword_3_1; }
		
		//name=EString
		public Assignment getNameAssignment_3_2() { return cNameAssignment_3_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_3_2_0() { return cNameEStringParserRuleCall_3_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3_3() { return cEqualsSignKeyword_3_3; }
		
		//'calloc'
		public Keyword getCallocKeyword_3_4() { return cCallocKeyword_3_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_5() { return cLeftParenthesisKeyword_3_5; }
		
		//MathematicalFormula
		public RuleCall getMathematicalFormulaParserRuleCall_3_6() { return cMathematicalFormulaParserRuleCall_3_6; }
		
		//','
		public Keyword getCommaKeyword_3_7() { return cCommaKeyword_3_7; }
		
		//MathematicalFormula
		public RuleCall getMathematicalFormulaParserRuleCall_3_8() { return cMathematicalFormulaParserRuleCall_3_8; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_9() { return cRightParenthesisKeyword_3_9; }
	}
	public class CExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionCExpressionHelperParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionForLoopParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		////    '{'
		////        ('endname' endname=EString)?
		////        ('value' value=EString)?
		////        ('type' type=EString)?
		////        ('elementType' elementType=EString)?
		////        ('size' size=EInt)?
		////        ('superType' superType=[CType|EString])?
		////        ('arrayElements' '{' arrayElements+=CArrayElement ( "," arrayElements+=CArrayElement)* '}' )?
		////    '}';
		////CArrayElement returns CArrayElement:
		////    {CArrayElement}
		////    type=EString
		////    name=EString
		////    index=EInt
		////    value=EString
		////;
		//CExpression returns xc::CExpression:
		//    expression=(CExpressionHelper) | expression=(ForLoop);
		@Override public ParserRule getRule() { return rule; }
		
		//expression=(CExpressionHelper) | expression=(ForLoop)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//expression=(CExpressionHelper)
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//(CExpressionHelper)
		public RuleCall getExpressionCExpressionHelperParserRuleCall_0_0() { return cExpressionCExpressionHelperParserRuleCall_0_0; }
		
		//expression=(ForLoop)
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//(ForLoop)
		public RuleCall getExpressionForLoopParserRuleCall_1_0() { return cExpressionForLoopParserRuleCall_1_0; }
	}
	public class CExpressionHelperElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CExpressionHelper");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPreConditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMathematicalFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cArrayLenParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//CExpressionHelper returns ecore::EString:
		//    PreCondition | MathematicalFormula | ArrayLen
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//PreCondition | MathematicalFormula | ArrayLen
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PreCondition
		public RuleCall getPreConditionParserRuleCall_0() { return cPreConditionParserRuleCall_0; }
		
		//MathematicalFormula
		public RuleCall getMathematicalFormulaParserRuleCall_1() { return cMathematicalFormulaParserRuleCall_1; }
		
		//ArrayLen
		public RuleCall getArrayLenParserRuleCall_2() { return cArrayLenParserRuleCall_2; }
	}
	public class PreConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.PreCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cPredicateParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final RuleCall cCExpressionHelperParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// Essentially the grammar for an if statement
		//PreCondition returns ecore::EString:
		//    // Used to declare a guard containing basic mathematical comparisons
		//    'if' '(' Predicate ')' '{'
		//        CExpressionHelper
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// Used to declare a guard containing basic mathematical comparisons
		//'if' '(' Predicate ')' '{'
		//    CExpressionHelper
		//'}'
		public Group getGroup() { return cGroup; }
		
		//// Used to declare a guard containing basic mathematical comparisons
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_2() { return cPredicateParserRuleCall_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//CExpressionHelper
		public RuleCall getCExpressionHelperParserRuleCall_5() { return cCExpressionHelperParserRuleCall_5; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cEStringParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cFormulaParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final RuleCall cMathematicalFormulaParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cLeftCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final RuleCall cCExpressionHelperParserRuleCall_9 = (RuleCall)cGroup.eContents().get(9);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//ForLoop returns ecore::EString:
		//    'for' '(' EString ';' Formula ';' MathematicalFormula ')' '{'
		//        CExpressionHelper
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'for' '(' EString ';' Formula ';' MathematicalFormula ')' '{'
		//    CExpressionHelper
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//EString
		public RuleCall getEStringParserRuleCall_2() { return cEStringParserRuleCall_2; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
		
		//Formula
		public RuleCall getFormulaParserRuleCall_4() { return cFormulaParserRuleCall_4; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
		
		//MathematicalFormula
		public RuleCall getMathematicalFormulaParserRuleCall_6() { return cMathematicalFormulaParserRuleCall_6; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_8() { return cLeftCurlyBracketKeyword_8; }
		
		//CExpressionHelper
		public RuleCall getCExpressionHelperParserRuleCall_9() { return cCExpressionHelperParserRuleCall_9; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }
	}
	public class ArrayLenElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.ArrayLen");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSizeofKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cEStringParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cSolidusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSizeofKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final RuleCall cEStringParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Keyword cLeftSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cDigitZeroKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cRightSquareBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//ArrayLen returns ecore::EString:
		//    'sizeof' '*' EString '/' 'sizeof' EString '[' '0' ']'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'sizeof' '*' EString '/' 'sizeof' EString '[' '0' ']'
		public Group getGroup() { return cGroup; }
		
		//'sizeof'
		public Keyword getSizeofKeyword_0() { return cSizeofKeyword_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
		
		//EString
		public RuleCall getEStringParserRuleCall_2() { return cEStringParserRuleCall_2; }
		
		//'/'
		public Keyword getSolidusKeyword_3() { return cSolidusKeyword_3; }
		
		//'sizeof'
		public Keyword getSizeofKeyword_4() { return cSizeofKeyword_4; }
		
		//EString
		public RuleCall getEStringParserRuleCall_5() { return cEStringParserRuleCall_5; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_6() { return cLeftSquareBracketKeyword_6; }
		
		//'0'
		public Keyword getDigitZeroKeyword_7() { return cDigitZeroKeyword_7; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_8() { return cRightSquareBracketKeyword_8; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.Predicate");
		private final Keyword cTestKeyword = (Keyword)rule.eContents().get(1);
		
		//Predicate returns ecore::EString:
		//    'test'
		////    Formula (LogicalOperators Predicate)* | // Predicate using basic mathematical operations
		////    (EString '==' EBoolean) (LogicalOperators Predicate)* // Predicate using set theory constructs
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'test'
		public Keyword getTestKeyword() { return cTestKeyword; }
	}
	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.Formula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cGreaterThanSignEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cExclamationMarkEqualsSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Keyword cLeftParenthesisKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final RuleCall cFormulaParserRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		
		////predicate_helper_function_call:
		////    (parameters += CParameter)+
		////;
		//Formula returns ecore::EString:
		//    (
		//    INT |
		//    ID |
		//    '==' |
		//    '<' |
		//    '>' |
		//    '>=' |
		//    '<=' |
		//    '!=' |
		//    ('(' Formula ')')
		//    )+;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//INT |
		//ID |
		//'==' |
		//'<' |
		//'>' |
		//'>=' |
		//'<=' |
		//'!=' |
		//('(' Formula ')')
		//)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
		
		//'=='
		public Keyword getEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignKeyword_2; }
		
		//'<'
		public Keyword getLessThanSignKeyword_3() { return cLessThanSignKeyword_3; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_5() { return cGreaterThanSignEqualsSignKeyword_5; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }
		
		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_7() { return cExclamationMarkEqualsSignKeyword_7; }
		
		//('(' Formula ')')
		public Group getGroup_8() { return cGroup_8; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_8_0() { return cLeftParenthesisKeyword_8_0; }
		
		//Formula
		public RuleCall getFormulaParserRuleCall_8_1() { return cFormulaParserRuleCall_8_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8_2() { return cRightParenthesisKeyword_8_2; }
	}
	public class MathematicalFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.MathematicalFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//MathematicalFormula returns ecore::EString:
		////    (
		////    INT |
		////    ID |
		////    '+' |
		////    '-' |
		////    '*' |
		////    '/' |
		////    ('(' IntegerFormula ')')
		////    )+ |
		//    '++' |
		//    '--'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////    (
		////    INT |
		////    ID |
		////    '+' |
		////    '-' |
		////    '*' |
		////    '/' |
		////    ('(' IntegerFormula ')')
		////    )+ |
		//    '++' |
		//    '--'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////    (
		////    INT |
		////    ID |
		////    '+' |
		////    '-' |
		////    '*' |
		////    '/' |
		////    ('(' IntegerFormula ')')
		////    )+ |
		//    '++'
		public Keyword getPlusSignPlusSignKeyword_0() { return cPlusSignPlusSignKeyword_0; }
		
		//'--'
		public Keyword getHyphenMinusHyphenMinusKeyword_1() { return cHyphenMinusHyphenMinusKeyword_1; }
	}
	public class IntegerFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.IntegerFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIntegerFormulaParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//IntegerFormula returns ecore::EString:
		//    (
		//    INT |
		//    ID |
		//    ('(' IntegerFormula ')')
		//    )+;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//INT |
		//ID |
		//('(' IntegerFormula ')')
		//)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
		
		//('(' IntegerFormula ')')
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//IntegerFormula
		public RuleCall getIntegerFormulaParserRuleCall_2_1() { return cIntegerFormulaParserRuleCall_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}
	public class CTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCTypeAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cCIntParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cCTypeAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cCBooleanParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cCStructParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCEnumerationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////LogicalOperators returns ecore::EString:
		////    '&&' |
		////    '||'
		////;
		//// Used for type references
		////CType returns CType:
		////    CInt | CBoolean | CStruct_type | CEnum_type | CArray_type | CPointer_type | CStruct | CEnumeration;
		//CType returns xc::CType:
		//    {xc::CType} CInt | {xc::CType} CBoolean | CStruct | CEnumeration;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CType} CInt | {xc::CType} CBoolean | CStruct | CEnumeration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{xc::CType} CInt
		public Group getGroup_0() { return cGroup_0; }
		
		//{xc::CType}
		public Action getCTypeAction_0_0() { return cCTypeAction_0_0; }
		
		//CInt
		public RuleCall getCIntParserRuleCall_0_1() { return cCIntParserRuleCall_0_1; }
		
		//{xc::CType} CBoolean
		public Group getGroup_1() { return cGroup_1; }
		
		//{xc::CType}
		public Action getCTypeAction_1_0() { return cCTypeAction_1_0; }
		
		//CBoolean
		public RuleCall getCBooleanParserRuleCall_1_1() { return cCBooleanParserRuleCall_1_1; }
		
		//CStruct
		public RuleCall getCStructParserRuleCall_2() { return cCStructParserRuleCall_2; }
		
		//CEnumeration
		public RuleCall getCEnumerationParserRuleCall_3() { return cCEnumerationParserRuleCall_3; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////CType_Impl returns CType:
		////    {CType}
		////    'CType'
		////    name=EString
		////    '{'
		////        ('endname' endname=EString)?
		////    '}';
		//EString returns ecore::EString:
		//    STRING | ID;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	public class EBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.EBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDigitOneKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDigitZeroKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EBoolean returns ecore::EBoolean:
		//    '1' | '0';
		@Override public ParserRule getRule() { return rule; }
		
		//'1' | '0'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'1'
		public Keyword getDigitOneKeyword_0() { return cDigitOneKeyword_0; }
		
		//'0'
		public Keyword getDigitZeroKeyword_1() { return cDigitZeroKeyword_1; }
	}
	public class EIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.EInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EInt returns ecore::EInt:
		//    '-'? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class CIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//CInt returns ecore::EString:
		//    '-'? INT
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class CBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDigitOneKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDigitZeroKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//CBoolean returns ecore::EString:
		//    '1' | '0'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'1' | '0'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'1'
		public Keyword getDigitOneKeyword_0() { return cDigitOneKeyword_0; }
		
		//'0'
		public Keyword getDigitZeroKeyword_1() { return cDigitZeroKeyword_1; }
	}
	public class CStructElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CStruct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCStructAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTypedefKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cStructKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameEStringParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cFieldsAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cFieldsCFieldParserRuleCall_5_0_0 = (RuleCall)cFieldsAssignment_5_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cTypeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cTypeEStringParserRuleCall_7_0 = (RuleCall)cTypeAssignment_7.eContents().get(0);
		
		//CStruct returns xc::CStruct:
		//    {xc::CStruct}
		//    'typedef' 'struct' name=EString '{'
		//        (fields+=CField ';')*
		//    '}' type=EString;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CStruct}
		//'typedef' 'struct' name=EString '{'
		//    (fields+=CField ';')*
		//'}' type=EString
		public Group getGroup() { return cGroup; }
		
		//{xc::CStruct}
		public Action getCStructAction_0() { return cCStructAction_0; }
		
		//'typedef'
		public Keyword getTypedefKeyword_1() { return cTypedefKeyword_1; }
		
		//'struct'
		public Keyword getStructKeyword_2() { return cStructKeyword_2; }
		
		//name=EString
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_3_0() { return cNameEStringParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//(fields+=CField ';')*
		public Group getGroup_5() { return cGroup_5; }
		
		//fields+=CField
		public Assignment getFieldsAssignment_5_0() { return cFieldsAssignment_5_0; }
		
		//CField
		public RuleCall getFieldsCFieldParserRuleCall_5_0_0() { return cFieldsCFieldParserRuleCall_5_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5_1() { return cSemicolonKeyword_5_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
		
		//type=EString
		public Assignment getTypeAssignment_7() { return cTypeAssignment_7; }
		
		//EString
		public RuleCall getTypeEStringParserRuleCall_7_0() { return cTypeEStringParserRuleCall_7_0; }
	}
	public class CFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCFieldAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cEStringParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//CField returns xc::CField:
		//    {xc::CField}
		//    EString
		//    name=EString
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CField}
		//EString
		//name=EString
		public Group getGroup() { return cGroup; }
		
		//{xc::CField}
		public Action getCFieldAction_0() { return cCFieldAction_0; }
		
		//EString
		public RuleCall getEStringParserRuleCall_1() { return cEStringParserRuleCall_1; }
		
		//name=EString
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_0() { return cNameEStringParserRuleCall_2_0; }
	}
	public class CEnumerationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CEnumeration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCEnumerationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTypedefKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEnumKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameEStringParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cEnumPropertiesAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cEnumPropertiesCEnumPropertiesParserRuleCall_5_0_0 = (RuleCall)cEnumPropertiesAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cEnumPropertiesAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cEnumPropertiesCEnumPropertiesParserRuleCall_5_1_1_0 = (RuleCall)cEnumPropertiesAssignment_5_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cEStringParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		//CEnumeration returns xc::CEnumeration:
		//    {xc::CEnumeration}
		//    'typedef' 'enum' name=EString '{'
		//        (enumProperties += CEnumProperties ( "," enumProperties+=CEnumProperties)*)?
		//    '}' EString
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CEnumeration}
		//'typedef' 'enum' name=EString '{'
		//    (enumProperties += CEnumProperties ( "," enumProperties+=CEnumProperties)*)?
		//'}' EString
		public Group getGroup() { return cGroup; }
		
		//{xc::CEnumeration}
		public Action getCEnumerationAction_0() { return cCEnumerationAction_0; }
		
		//'typedef'
		public Keyword getTypedefKeyword_1() { return cTypedefKeyword_1; }
		
		//'enum'
		public Keyword getEnumKeyword_2() { return cEnumKeyword_2; }
		
		//name=EString
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_3_0() { return cNameEStringParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//(enumProperties += CEnumProperties ( "," enumProperties+=CEnumProperties)*)?
		public Group getGroup_5() { return cGroup_5; }
		
		//enumProperties += CEnumProperties
		public Assignment getEnumPropertiesAssignment_5_0() { return cEnumPropertiesAssignment_5_0; }
		
		//CEnumProperties
		public RuleCall getEnumPropertiesCEnumPropertiesParserRuleCall_5_0_0() { return cEnumPropertiesCEnumPropertiesParserRuleCall_5_0_0; }
		
		//( "," enumProperties+=CEnumProperties)*
		public Group getGroup_5_1() { return cGroup_5_1; }
		
		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }
		
		//enumProperties+=CEnumProperties
		public Assignment getEnumPropertiesAssignment_5_1_1() { return cEnumPropertiesAssignment_5_1_1; }
		
		//CEnumProperties
		public RuleCall getEnumPropertiesCEnumPropertiesParserRuleCall_5_1_1_0() { return cEnumPropertiesCEnumPropertiesParserRuleCall_5_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
		
		//EString
		public RuleCall getEStringParserRuleCall_7() { return cEStringParserRuleCall_7; }
	}
	public class CEnumPropertiesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CEnumProperties");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCEnumPropertiesAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//CEnumProperties returns xc::CEnumProperties:
		//    {xc::CEnumProperties}
		//    name=EString
		////    integralConstant=EInt
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CEnumProperties}
		//name=EString
		public Group getGroup() { return cGroup; }
		
		//{xc::CEnumProperties}
		public Action getCEnumPropertiesAction_0() { return cCEnumPropertiesAction_0; }
		
		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
	}
	public class CPointerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xtext.Xc.CPointer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCPointerAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////CArray_type returns ecore::EString:
		////    type=EString '*'
		////    name=EString
		////;
		////
		////CStruct_type returns ecore::EString:
		////    name=EString
		////;
		////
		////CEnum_type returns ecore::EString:
		////    'enum' name=EString
		////;
		////
		////CPointer_type returns ecore::EString:
		////    name=CInt '*' | name=CBoolean '*' | name=CStruct_type '*' | name=CEnum_type '*'
		////;
		////CDerivedType_Impl returns CDerivedType:
		////    {CDerivedType}
		////    'CDerivedType'
		////    name=EString
		////    '{'
		////        ('endname' endname=EString)?
		////        ('superType' superType=[CType|EString])?
		////    '}';
		////CDiscreteType_Impl returns CDiscreteType:
		////    {CDiscreteType}
		////    'CDiscreteType'
		////    name=EString
		////    '{'
		////        ('endname' endname=EString)?
		////    '}';
		//// Creates a new pointer type e.g. int*, pointer variables are dealt with separately -> see CVariable
		//CPointer returns xc::CPointer:
		//    {xc::CPointer}
		//    name=EString '*'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{xc::CPointer}
		//name=EString '*'
		public Group getGroup() { return cGroup; }
		
		//{xc::CPointer}
		public Action getCPointerAction_0() { return cCPointerAction_0; }
		
		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_2() { return cAsteriskKeyword_2; }
	}
	
	
	private final CSourceFileElements pCSourceFile;
	private final CIncludeDirectiveElements pCIncludeDirective;
	private final ContextElements pContext;
	private final InitialisationElements pInitialisation;
	private final MainElements pMain;
	private final CSubProgramElements pCSubProgram;
	private final CFunctionElements pCFunction;
	private final CProcedureElements pCProcedure;
	private final CPreConditionElements pCPreCondition;
	private final CParameterElements pCParameter;
	private final CVariableElements pCVariable;
	private final CVariable_ImplElements pCVariable_Impl;
	private final CArrayVariableElements pCArrayVariable;
	private final CExpressionElements pCExpression;
	private final CExpressionHelperElements pCExpressionHelper;
	private final PreConditionElements pPreCondition;
	private final ForLoopElements pForLoop;
	private final ArrayLenElements pArrayLen;
	private final PredicateElements pPredicate;
	private final FormulaElements pFormula;
	private final MathematicalFormulaElements pMathematicalFormula;
	private final IntegerFormulaElements pIntegerFormula;
	private final CTypeElements pCType;
	private final EStringElements pEString;
	private final EBooleanElements pEBoolean;
	private final EIntElements pEInt;
	private final CIntElements pCInt;
	private final CBooleanElements pCBoolean;
	private final CStructElements pCStruct;
	private final CFieldElements pCField;
	private final CEnumerationElements pCEnumeration;
	private final CEnumPropertiesElements pCEnumProperties;
	private final CPointerElements pCPointer;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public XcGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pCSourceFile = new CSourceFileElements();
		this.pCIncludeDirective = new CIncludeDirectiveElements();
		this.pContext = new ContextElements();
		this.pInitialisation = new InitialisationElements();
		this.pMain = new MainElements();
		this.pCSubProgram = new CSubProgramElements();
		this.pCFunction = new CFunctionElements();
		this.pCProcedure = new CProcedureElements();
		this.pCPreCondition = new CPreConditionElements();
		this.pCParameter = new CParameterElements();
		this.pCVariable = new CVariableElements();
		this.pCVariable_Impl = new CVariable_ImplElements();
		this.pCArrayVariable = new CArrayVariableElements();
		this.pCExpression = new CExpressionElements();
		this.pCExpressionHelper = new CExpressionHelperElements();
		this.pPreCondition = new PreConditionElements();
		this.pForLoop = new ForLoopElements();
		this.pArrayLen = new ArrayLenElements();
		this.pPredicate = new PredicateElements();
		this.pFormula = new FormulaElements();
		this.pMathematicalFormula = new MathematicalFormulaElements();
		this.pIntegerFormula = new IntegerFormulaElements();
		this.pCType = new CTypeElements();
		this.pEString = new EStringElements();
		this.pEBoolean = new EBooleanElements();
		this.pEInt = new EIntElements();
		this.pCInt = new CIntElements();
		this.pCBoolean = new CBooleanElements();
		this.pCStruct = new CStructElements();
		this.pCField = new CFieldElements();
		this.pCEnumeration = new CEnumerationElements();
		this.pCEnumProperties = new CEnumPropertiesElements();
		this.pCPointer = new CPointerElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.xtext.Xc".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//CSourceFile returns xc::CSourceFile:
	//    {xc::CSourceFile}
	////    (includeDirectives += CIncludeDirective |
	////    types += CType |
	////    globalVariables += CVariable |
	////    subPrograms += CSubProgram
	////)*
	//    subPrograms += Context
	//    subPrograms += Initialisation
	//    subPrograms += Main
	//;
	public CSourceFileElements getCSourceFileAccess() {
		return pCSourceFile;
	}
	
	public ParserRule getCSourceFileRule() {
		return getCSourceFileAccess().getRule();
	}
	
	//CIncludeDirective returns xc::CIncludeDirective:
	//    {xc::CIncludeDirective}
	//    '#include' '<' name=EString '>';
	public CIncludeDirectiveElements getCIncludeDirectiveAccess() {
		return pCIncludeDirective;
	}
	
	public ParserRule getCIncludeDirectiveRule() {
		return getCIncludeDirectiveAccess().getRule();
	}
	
	//Context returns xc::CProcedure:
	//    name="context"
	//    (
	//        '(' ')'
	//    )?
	//    '{'
	//        (
	//            localVariables += CVariable |
	//            body += CExpression
	//        )*
	//    '}'
	//;
	public ContextElements getContextAccess() {
		return pContext;
	}
	
	public ParserRule getContextRule() {
		return getContextAccess().getRule();
	}
	
	//Initialisation returns xc::CProcedure:
	//    name="initialisation"
	//    (
	//        '(' ')'
	//    )?
	//    '{'
	//        (
	//            localVariables += CVariable |
	//            body += CExpression
	//        )*
	//    '}'
	//;
	public InitialisationElements getInitialisationAccess() {
		return pInitialisation;
	}
	
	public ParserRule getInitialisationRule() {
		return getInitialisationAccess().getRule();
	}
	
	//Main returns xc::CProcedure:
	//    name="main"
	//    (
	//        '(' ')'
	//    )?
	//    '{'
	//        (
	//            localVariables += CVariable |
	//            body += CExpression
	//        )*
	//    '}'
	//;
	public MainElements getMainAccess() {
		return pMain;
	}
	
	public ParserRule getMainRule() {
		return getMainAccess().getRule();
	}
	
	//CSubProgram returns xc::CSubProgram:
	//    CFunction | CProcedure;
	public CSubProgramElements getCSubProgramAccess() {
		return pCSubProgram;
	}
	
	public ParserRule getCSubProgramRule() {
		return getCSubProgramAccess().getRule();
	}
	
	//CFunction returns xc::CFunction:
	//    {xc::CFunction}
	//    returnType=EString
	//    name=EString
	//    (
	//        '('
	//        parameters += CParameter ( "," parameters += CParameter)*
	//        ')'
	//    )?
	//    '{'
	//        preconditions += CPreCondition
	//        (
	//            localVariables += CVariable |
	//            body += CExpression
	//        )*
	//        'return' returnStatement=CExpression
	//    '}' endname=EString;
	public CFunctionElements getCFunctionAccess() {
		return pCFunction;
	}
	
	public ParserRule getCFunctionRule() {
		return getCFunctionAccess().getRule();
	}
	
	//CProcedure returns xc::CProcedure:
	//    {xc::CProcedure}
	//    name=EString
	//    (
	//        '('
	//        parameters += CParameter ( "," parameters += CParameter)*
	//        ')'
	//    )?
	//    '{'
	//        preconditions += CPreCondition
	//        (
	//            localVariables += CVariable |
	//            body += CExpression
	//        )*
	//    '}'
	//;
	public CProcedureElements getCProcedureAccess() {
		return pCProcedure;
	}
	
	public ParserRule getCProcedureRule() {
		return getCProcedureAccess().getRule();
	}
	
	//CPreCondition returns xc::CPreCondition:
	//    // Used to declare a guard containing basic mathematical comparisons
	//    'if' '(' Predicate ')' '{'
	//        expression=CExpressionHelper
	//    '}'
	//;
	public CPreConditionElements getCPreConditionAccess() {
		return pCPreCondition;
	}
	
	public ParserRule getCPreConditionRule() {
		return getCPreConditionAccess().getRule();
	}
	
	//CParameter returns xc::CParameter:
	//    {xc::CParameter}
	//    type=EString
	//    name=EString;
	public CParameterElements getCParameterAccess() {
		return pCParameter;
	}
	
	public ParserRule getCParameterRule() {
		return getCParameterAccess().getRule();
	}
	
	//CVariable returns xc::CVariable:
	//    CVariable_Impl | CArrayVariable;
	public CVariableElements getCVariableAccess() {
		return pCVariable;
	}
	
	public ParserRule getCVariableRule() {
		return getCVariableAccess().getRule();
	}
	
	//CVariable_Impl returns xc::CVariable:
	//    {xc::CVariable}
	//    (isConstant?='const')?
	//    type=EString // This includes some types e.g. structs and enums which cannot be used but correctly covers pointers
	//    name=EString
	//    ('=' value=EString)? // set to some value or variable
	//;
	public CVariable_ImplElements getCVariable_ImplAccess() {
		return pCVariable_Impl;
	}
	
	public ParserRule getCVariable_ImplRule() {
		return getCVariable_ImplAccess().getRule();
	}
	
	//CArrayVariable returns xc::CArrayVariable:
	//    {xc::CArrayVariable}
	//    type=EString'*'
	//    name=EString |
	//    (type=EString)? name=EString '[' EInt ']' '=' value=EString |
	//    type=EString '*' name=EString '=' 'malloc' '(' size=EInt ')'|
	//    type=EString '*' name=EString '=' 'calloc' '(' MathematicalFormula ',' MathematicalFormula ')'
	//;
	public CArrayVariableElements getCArrayVariableAccess() {
		return pCArrayVariable;
	}
	
	public ParserRule getCArrayVariableRule() {
		return getCArrayVariableAccess().getRule();
	}
	
	////    '{'
	////        ('endname' endname=EString)?
	////        ('value' value=EString)?
	////        ('type' type=EString)?
	////        ('elementType' elementType=EString)?
	////        ('size' size=EInt)?
	////        ('superType' superType=[CType|EString])?
	////        ('arrayElements' '{' arrayElements+=CArrayElement ( "," arrayElements+=CArrayElement)* '}' )?
	////    '}';
	////CArrayElement returns CArrayElement:
	////    {CArrayElement}
	////    type=EString
	////    name=EString
	////    index=EInt
	////    value=EString
	////;
	//CExpression returns xc::CExpression:
	//    expression=(CExpressionHelper) | expression=(ForLoop);
	public CExpressionElements getCExpressionAccess() {
		return pCExpression;
	}
	
	public ParserRule getCExpressionRule() {
		return getCExpressionAccess().getRule();
	}
	
	//CExpressionHelper returns ecore::EString:
	//    PreCondition | MathematicalFormula | ArrayLen
	//;
	public CExpressionHelperElements getCExpressionHelperAccess() {
		return pCExpressionHelper;
	}
	
	public ParserRule getCExpressionHelperRule() {
		return getCExpressionHelperAccess().getRule();
	}
	
	//// Essentially the grammar for an if statement
	//PreCondition returns ecore::EString:
	//    // Used to declare a guard containing basic mathematical comparisons
	//    'if' '(' Predicate ')' '{'
	//        CExpressionHelper
	//    '}'
	//;
	public PreConditionElements getPreConditionAccess() {
		return pPreCondition;
	}
	
	public ParserRule getPreConditionRule() {
		return getPreConditionAccess().getRule();
	}
	
	//ForLoop returns ecore::EString:
	//    'for' '(' EString ';' Formula ';' MathematicalFormula ')' '{'
	//        CExpressionHelper
	//    '}'
	//;
	public ForLoopElements getForLoopAccess() {
		return pForLoop;
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}
	
	//ArrayLen returns ecore::EString:
	//    'sizeof' '*' EString '/' 'sizeof' EString '[' '0' ']'
	//;
	public ArrayLenElements getArrayLenAccess() {
		return pArrayLen;
	}
	
	public ParserRule getArrayLenRule() {
		return getArrayLenAccess().getRule();
	}
	
	//Predicate returns ecore::EString:
	//    'test'
	////    Formula (LogicalOperators Predicate)* | // Predicate using basic mathematical operations
	////    (EString '==' EBoolean) (LogicalOperators Predicate)* // Predicate using set theory constructs
	//;
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	////predicate_helper_function_call:
	////    (parameters += CParameter)+
	////;
	//Formula returns ecore::EString:
	//    (
	//    INT |
	//    ID |
	//    '==' |
	//    '<' |
	//    '>' |
	//    '>=' |
	//    '<=' |
	//    '!=' |
	//    ('(' Formula ')')
	//    )+;
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}
	
	//MathematicalFormula returns ecore::EString:
	////    (
	////    INT |
	////    ID |
	////    '+' |
	////    '-' |
	////    '*' |
	////    '/' |
	////    ('(' IntegerFormula ')')
	////    )+ |
	//    '++' |
	//    '--'
	//;
	public MathematicalFormulaElements getMathematicalFormulaAccess() {
		return pMathematicalFormula;
	}
	
	public ParserRule getMathematicalFormulaRule() {
		return getMathematicalFormulaAccess().getRule();
	}
	
	//IntegerFormula returns ecore::EString:
	//    (
	//    INT |
	//    ID |
	//    ('(' IntegerFormula ')')
	//    )+;
	public IntegerFormulaElements getIntegerFormulaAccess() {
		return pIntegerFormula;
	}
	
	public ParserRule getIntegerFormulaRule() {
		return getIntegerFormulaAccess().getRule();
	}
	
	////LogicalOperators returns ecore::EString:
	////    '&&' |
	////    '||'
	////;
	//// Used for type references
	////CType returns CType:
	////    CInt | CBoolean | CStruct_type | CEnum_type | CArray_type | CPointer_type | CStruct | CEnumeration;
	//CType returns xc::CType:
	//    {xc::CType} CInt | {xc::CType} CBoolean | CStruct | CEnumeration;
	public CTypeElements getCTypeAccess() {
		return pCType;
	}
	
	public ParserRule getCTypeRule() {
		return getCTypeAccess().getRule();
	}
	
	////CType_Impl returns CType:
	////    {CType}
	////    'CType'
	////    name=EString
	////    '{'
	////        ('endname' endname=EString)?
	////    '}';
	//EString returns ecore::EString:
	//    STRING | ID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//EBoolean returns ecore::EBoolean:
	//    '1' | '0';
	public EBooleanElements getEBooleanAccess() {
		return pEBoolean;
	}
	
	public ParserRule getEBooleanRule() {
		return getEBooleanAccess().getRule();
	}
	
	//EInt returns ecore::EInt:
	//    '-'? INT;
	public EIntElements getEIntAccess() {
		return pEInt;
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}
	
	//CInt returns ecore::EString:
	//    '-'? INT
	//;
	public CIntElements getCIntAccess() {
		return pCInt;
	}
	
	public ParserRule getCIntRule() {
		return getCIntAccess().getRule();
	}
	
	//CBoolean returns ecore::EString:
	//    '1' | '0'
	//;
	public CBooleanElements getCBooleanAccess() {
		return pCBoolean;
	}
	
	public ParserRule getCBooleanRule() {
		return getCBooleanAccess().getRule();
	}
	
	//CStruct returns xc::CStruct:
	//    {xc::CStruct}
	//    'typedef' 'struct' name=EString '{'
	//        (fields+=CField ';')*
	//    '}' type=EString;
	public CStructElements getCStructAccess() {
		return pCStruct;
	}
	
	public ParserRule getCStructRule() {
		return getCStructAccess().getRule();
	}
	
	//CField returns xc::CField:
	//    {xc::CField}
	//    EString
	//    name=EString
	//;
	public CFieldElements getCFieldAccess() {
		return pCField;
	}
	
	public ParserRule getCFieldRule() {
		return getCFieldAccess().getRule();
	}
	
	//CEnumeration returns xc::CEnumeration:
	//    {xc::CEnumeration}
	//    'typedef' 'enum' name=EString '{'
	//        (enumProperties += CEnumProperties ( "," enumProperties+=CEnumProperties)*)?
	//    '}' EString
	//;
	public CEnumerationElements getCEnumerationAccess() {
		return pCEnumeration;
	}
	
	public ParserRule getCEnumerationRule() {
		return getCEnumerationAccess().getRule();
	}
	
	//CEnumProperties returns xc::CEnumProperties:
	//    {xc::CEnumProperties}
	//    name=EString
	////    integralConstant=EInt
	//;
	public CEnumPropertiesElements getCEnumPropertiesAccess() {
		return pCEnumProperties;
	}
	
	public ParserRule getCEnumPropertiesRule() {
		return getCEnumPropertiesAccess().getRule();
	}
	
	////CArray_type returns ecore::EString:
	////    type=EString '*'
	////    name=EString
	////;
	////
	////CStruct_type returns ecore::EString:
	////    name=EString
	////;
	////
	////CEnum_type returns ecore::EString:
	////    'enum' name=EString
	////;
	////
	////CPointer_type returns ecore::EString:
	////    name=CInt '*' | name=CBoolean '*' | name=CStruct_type '*' | name=CEnum_type '*'
	////;
	////CDerivedType_Impl returns CDerivedType:
	////    {CDerivedType}
	////    'CDerivedType'
	////    name=EString
	////    '{'
	////        ('endname' endname=EString)?
	////        ('superType' superType=[CType|EString])?
	////    '}';
	////CDiscreteType_Impl returns CDiscreteType:
	////    {CDiscreteType}
	////    'CDiscreteType'
	////    name=EString
	////    '{'
	////        ('endname' endname=EString)?
	////    '}';
	//// Creates a new pointer type e.g. int*, pointer variables are dealt with separately -> see CVariable
	//CPointer returns xc::CPointer:
	//    {xc::CPointer}
	//    name=EString '*'
	//;
	public CPointerElements getCPointerAccess() {
		return pCPointer;
	}
	
	public ParserRule getCPointerRule() {
		return getCPointerAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

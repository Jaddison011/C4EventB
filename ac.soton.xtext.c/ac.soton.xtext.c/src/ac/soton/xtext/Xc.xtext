// automatically generated by Xtext
grammar ac.soton.xtext.Xc with org.eclipse.xtext.common.Terminals

import "http://ac/soton/eventb/c" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// TODO: Figure out how to declare arrays / separate the declaration and initialisation of arrayVariables and types
// TODO: Figure out how to declare and create calls of helper functions for predicates
// TODO: Expressions/main code body
// TODO: Figure out grammar for typing

CSourceFile returns CSourceFile:
	{CSourceFile}
	(includeDirectives += CIncludeDirective |
	types += CType |
	globalVariables += CVariable |
	subPrograms += CSubProgram)*
	subPrograms += Context
	subPrograms += Initialisation
	SubPrograms += Main
//	name=EString
;

CIncludeDirective returns CIncludeDirective:
	{CIncludeDirective}
	'#include' '<' name=EString '>';

CSubProgram returns CSubProgram:
	CFunction | CProcedure;

CFunction returns CFunction:
	{CFunction}
	returnType=EString
	name=EString
	(
		'('
		parameters += CParameter ( "," parameters += CParameter)*
		')'
	)?
	'{'
		preconditions += CPreCondition
		(
			localVariables += CVariable |
			body += CExpression 
		)*
		'return' returnStatement=CExpression
	'}' endname=EString;

CProcedure returns CProcedure:
	{CProcedure}
	name=EString
	(
		'('
		parameters += CParameter ( "," parameters += CParameter)*
		')'
	)?
	'{'
		preconditions += CPreCondition
		(
			localVariables += CVariable |
			body += CExpression 
		)*
	'}' endname=EString;

CParameter returns CParameter:
	{CParameter}
	type=EString
	name=EString;

CVariable returns CVariable:
	CVariable_Impl | CArrayVariable;

CVariable_Impl returns CVariable:
	{CVariable}
	(isConstant?='const')?
	type=CType // This includes some types e.g. structs and enums which cannot be used  
	name=EString
;

VariableInstantiation returns CVariable:
	CStruct | CEnumeration |
	type=CInt name=EString '=' value=CExpression | // set to some value
	type=CPointer name=EString '=' value=CVariable | // set a pointer to some variable
	type=CPointer name=EString '=' 'malloc' '(' size=CExpression ')'|  // initialise pointer memory using malloc
	type=CPointer name=EString '=' 'calloc' '(' size=CExpression ',' size=CExpression ')' // initialise pointer memory using calloc (used for boolean arrays)
;

CArrayVariable returns CArrayVariable:
	{CArrayVariable}
	type=CType '*'
	name=EString
;
//	'{'
//		('endname' endname=EString)?
//		('value' value=EString)?
//		('type' type=EString)?
//		('elementType' elementType=EString)?
//		('size' size=EInt)?
//		('superType' superType=[CType|EString])?
//		('arrayElements' '{' arrayElements+=CArrayElement ( "," arrayElements+=CArrayElement)* '}' )?
//	'}';

//CArrayElement returns CArrayElement:
//	{CArrayElement}
//	type=EString
//	name=EString
//	index=EInt
//	value=EString
//;

ArrayElementDeclaration returns CArrayElement:
	CArrayVariable '[' index=EInt ']' '=' value=EString
;

CExpression returns CExpression:
	CExpression_Impl | CPreCondition;

CExpression_Impl returns CExpression:
	{CExpression}
	'CExpression'
	'{'
		('expression' expression=EString)?
	'}';

CPreCondition returns CPreCondition:
	{CPreCondition}
	// Used to declare a guard containing basic mathematical comparisons
	'if' '(' predicate=Predicate ')' '{'
		(expression+=CExpression)*
	'}' 
	;

Predicate returns ecore::EString:
	Formula (LogicalOperators Predicate)* | // Predicate using basic mathematical operations
	(predicate_helper_function_call() '==' EBoolean) (LogicalOperators Predicate)* // Predicate using set theory constructs
;

predicate_helper_function_call:
	(parameters += CParameter)+
;

Formula returns ecore::EString:
	(
	INT |
	ID |
	'==' |
	'<' |
	'>' |
	'>=' |
	'<=' |
	'!=' |
	('(' Formula ')')
	)+;

IntegerFormula returns ecore::EString:
	(
	INT |
	ID |
	('(' IntegerFormula ')')
	)+;

LogicalOperators returns ecore::EString:
	'&&' |
	'||'
;

// Used for type references
CType returns CType:
	CInt | CBoolean | CStruct_type | CEnum_type | CArray_type | CPointer_type;

//CType_Impl returns CType:
//	{CType}
//	'CType'
//	name=EString
//	'{'
//		('endname' endname=EString)?
//	'}';	

EString returns ecore::EString:
	STRING | ID;

EBoolean returns ecore::EBoolean:
	'1' | '0';

EInt returns ecore::EInt:
	'-'? INT;
	
CInt returns CType:
	{CType} '-'? INT
;

CBoolean returns CType:
	{CType} '1' | {CType} '0'
;

CStruct returns CStruct:
	{CStruct}
	'typedef' 'struct' name=EString '{'
		(fields+=CField ';')*
	'}' type=EString;

CField returns CField:
	{CField}
	type=EString
	name=EString
;

CEnumeration returns CEnumeration:
	{CEnumeration}
	'typedef' 'enum' name=EString '{' 
		(enumProperties += CEnumProperties ( "," enumProperties+=CEnumProperties)*)?
	'}' type=EString
;

CEnumProperties returns CEnumProperties:
	{CEnumProperties}
	name=EString
//	integralConstant=EInt
	;

CArray_type returns CType:
	type=EString '*'
	name=EString
;

CStruct_type returns CType:
	name=EString
;

CEnum_type returns CType:
	'enum' name=EString
;

CPointer_type returns CType:
	name=CInt '*' | name=CBoolean '*' | name=CStruct_type '*' | name=CEnum_type '*'
;

//CDerivedType_Impl returns CDerivedType:
//	{CDerivedType}
//	'CDerivedType'
//	name=EString
//	'{'
//		('endname' endname=EString)?
//		('superType' superType=[CType|EString])?
//	'}';

//CDiscreteType_Impl returns CDiscreteType:
//	{CDiscreteType}
//	'CDiscreteType'
//	name=EString
//	'{'
//		('endname' endname=EString)?
//	'}';

// Creates a new pointer type e.g. int*, pointer variables are dealt with separately -> see CVariable
CPointer returns CPointer:
	{CPointer}
	type=EString '*'
;

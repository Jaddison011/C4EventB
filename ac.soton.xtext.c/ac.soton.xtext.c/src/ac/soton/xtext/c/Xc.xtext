// automatically generated by Xtext
grammar ac.soton.xtext.Xc with org.eclipse.xtext.common.Terminals

//import "http://ac.soton.eventb.c" as xc
import "http://ac/soton/eventb/c"as xc

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

CSourceFile returns xc::CSourceFile:
	{xc::CSourceFile}
	(includeDirectives += CIncludeDirective |
	types += CType |
	globalVariables += CVariable |
	subPrograms += CSubProgram
)*
	subPrograms += Context
	subPrograms += Initialisation
	subPrograms += Main
;

CIncludeDirective returns xc::CIncludeDirective:
	{xc::CIncludeDirective}
	'#include' '<' name=EString '>';

Context returns xc::CProcedure:
	name="context"
	(
		'(' ')'
	)?
	'{'
		(
			localVariables += CVariable |
			body += CExpression 
		)*
	'}'
;

Initialisation returns xc::CProcedure:
	name="initialisation"
	(
		'(' ')'
	)?
	'{'
		(
			localVariables += CVariable |
			body += CExpression 
		)*
	'}'
;

Main returns xc::CProcedure:
	name="main"
	(
		'(' ')'
	)?
	'{'
		(
			localVariables += CVariable |
			body += CExpression 
		)*
	'}'
;

CSubProgram returns xc::CSubProgram:
	CFunction | CProcedure;

CFunction returns xc::CFunction:
	{xc::CFunction}
	returnType=EString
	name=EString
	(
		'('
		parameters += CParameter ( "," parameters += CParameter)*
		')'
	)?
	'{'
		preconditions += CPreCondition
		(
			localVariables += CVariable |
			body += CExpression 
		)*
		'return' returnStatement=CExpression
	'}' endname=EString;

CProcedure returns xc::CProcedure:
	{xc::CProcedure}
	name=EString
	(
		'('
		parameters += CParameter ( "," parameters += CParameter)*
		')'
	)?
	'{'
		preconditions += CPreCondition
		(
			localVariables += CVariable |
			body += CExpression 
		)*
	'}'
;

CPreCondition returns xc::CPreCondition:
	// Used to declare a guard containing basic mathematical comparisons
	'if' '(' Predicate ')' '{'
		expression=CExpressionHelper
	'}' 
;

CParameter returns xc::CParameter:
	{xc::CParameter}
	type=EString
	name=EString;

CVariable returns xc::CVariable:
	CVariable_Impl | CArrayVariable;

CVariable_Impl returns xc::CVariable:
	{xc::CVariable}
	(isConstant?='const')?
	type=EString // This includes some types e.g. structs and enums which cannot be used but correctly covers pointers 
	name=EString
	('=' value=EString)? // set to some value or variable
;

CArrayVariable returns xc::CArrayVariable:
	{xc::CArrayVariable}
	type=EString'*'
	name=EString | 
	(type=EString)? name=EString '[' EInt ']' '=' value=EString |
	type=EString '*' name=EString '=' 'malloc' '(' size=EInt ')'|
	type=EString '*' name=EString '=' 'calloc' '(' MathematicalFormula ',' MathematicalFormula ')'
;
//	'{'
//		('endname' endname=EString)?
//		('value' value=EString)?
//		('type' type=EString)?
//		('elementType' elementType=EString)?
//		('size' size=EInt)?
//		('superType' superType=[CType|EString])?
//		('arrayElements' '{' arrayElements+=CArrayElement ( "," arrayElements+=CArrayElement)* '}' )?
//	'}';

//CArrayElement returns CArrayElement:
//	{CArrayElement}
//	type=EString
//	name=EString
//	index=EInt
//	value=EString
//;

CExpression returns xc::CExpression:
	expression=(CExpressionHelper) | expression=(ForLoop);


CExpressionHelper returns ecore::EString:
	PreCondition | MathematicalFormula | ArrayLen
;

// Essentially the grammar for an if statement
PreCondition returns ecore::EString:
	// Used to declare a guard containing basic mathematical comparisons
	'if' '(' Predicate ')' '{'
		CExpressionHelper
	'}' 
;

ForLoop returns ecore::EString:
	'for' '(' EString ';' Formula ';' MathematicalFormula ')' '{'
		CExpressionHelper
	'}'
;

ArrayLen returns ecore::EString:
	'sizeof' '*' EString '/' 'sizeof' EString '[' '0' ']'
;



Predicate returns ecore::EString:
	'test'
//	Formula (LogicalOperators Predicate)* | // Predicate using basic mathematical operations
//	(EString '==' EBoolean) (LogicalOperators Predicate)* // Predicate using set theory constructs
;

//predicate_helper_function_call:
//	(parameters += CParameter)+
//;

Formula returns ecore::EString:
	(
	INT |
	ID |
	'==' |
	'<' |
	'>' |
	'>=' |
	'<=' |
	'!=' |
	('(' Formula ')')
	)+;

MathematicalFormula returns ecore::EString:
//	(
//	INT |
//	ID |
//	'+' |
//	'-' |
//	'*' |
//	'/' |
//	('(' IntegerFormula ')')
//	)+ |
	'++' |
	'--'
;

IntegerFormula returns ecore::EString:
	(
	INT |
	ID |
	('(' IntegerFormula ')')
	)+;

//LogicalOperators returns ecore::EString:
//	'&&' |
//	'||'
//;

// Used for type references
//CType returns CType:
//	CInt | CBoolean | CStruct_type | CEnum_type | CArray_type | CPointer_type | CStruct | CEnumeration;
	
CType returns xc::CType:
	{xc::CType} CInt | {xc::CType} CBoolean | CStruct | CEnumeration;
	

//CType_Impl returns CType:
//	{CType}
//	'CType'
//	name=EString
//	'{'
//		('endname' endname=EString)?
//	'}';	

EString returns ecore::EString:
	STRING | ID;

EBoolean returns ecore::EBoolean:
	'1' | '0';

EInt returns ecore::EInt:
	'-'? INT;
	
CInt returns ecore::EString:
	'-'? INT
;

CBoolean returns ecore::EString:
	'1' | '0'
;

CStruct returns xc::CStruct:
	{xc::CStruct}
	'typedef' 'struct' name=EString '{'
		(fields+=CField ';')*
	'}' type=EString;

CField returns xc::CField:
	{xc::CField}
	EString
	name=EString
;

CEnumeration returns xc::CEnumeration:
	{xc::CEnumeration}
	'typedef' 'enum' name=EString '{' 
		(enumProperties += CEnumProperties ( "," enumProperties+=CEnumProperties)*)?
	'}' EString
;

CEnumProperties returns xc::CEnumProperties:
	{xc::CEnumProperties}
	name=EString
//	integralConstant=EInt
;

//CArray_type returns ecore::EString:
//	type=EString '*'
//	name=EString
//;
//
//CStruct_type returns ecore::EString:
//	name=EString
//;
//
//CEnum_type returns ecore::EString:
//	'enum' name=EString
//;
//
//CPointer_type returns ecore::EString:
//	name=CInt '*' | name=CBoolean '*' | name=CStruct_type '*' | name=CEnum_type '*'
//;

//CDerivedType_Impl returns CDerivedType:
//	{CDerivedType}
//	'CDerivedType'
//	name=EString
//	'{'
//		('endname' endname=EString)?
//		('superType' superType=[CType|EString])?
//	'}';

//CDiscreteType_Impl returns CDiscreteType:
//	{CDiscreteType}
//	'CDiscreteType'
//	name=EString
//	'{'
//		('endname' endname=EString)?
//	'}';

// Creates a new pointer type e.g. int*, pointer variables are dealt with separately -> see CVariable
CPointer returns xc::CPointer:
	{xc::CPointer}
	name=EString '*'
;
